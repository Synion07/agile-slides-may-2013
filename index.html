<!doctype html>
<html lang="en">
	<head>

		<title>SOLID y TDD</title>

		<meta name="description" content="Slides para explicar SOLID y TDD">
		<meta name="author" content="Iván Tomás">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/beige.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Metodologías Ágiles</h1>
					<h3>Parte técnica: TDD y SOLID</h3>
					<p>
						Una presentación de <b>Iván Tomás</b>
					</p>
					<aside class="notes">
						Presentación para explicar los conceptos detrás de las metodologías ágiles, y porqué son indispensables para generar software de calidad y mantenible
					</aside>
				</section>
				<section>
					<h2>¿Qué son?</h2>
					<div class="image">
						<img height="550" src="img/liquid.jpg">
					</div>
					<aside class="notes">
						El concepto de "agilidad" no viene desde el sentido de aumentar la velocidad de desarrollo (aunque suele ser una consecuencia de crear código de más calidad) si no que surge de la necesidad de poder reaccionar a la realidad de los proyectos software, y es que es necesario poder adaptarse a las necesidades cambiantes del cliente sin que esto penalice en exceso el tiempo de entrega y sin comprometer la calidad del código
					</aside>
				</section>
				<section>
					<section>
						<h2>¿Porqué hacen falta?</h2>
						<div class="image">
							<img height="550" src="img/clint.jpg">
						</div>
						<aside class="notes">
							El estilo habitual de desarrollo suele ser un "todo vale", también conocido como "cowboy coding", que consiste habitualmente en hacer las cosas lo más rápido posible teniendo en cuenta plazos, cuando realmente lo que se hace es añadir lentitud al hacer código de baja calidad que necesita más tiempo para ser probado y donde se pierde más tiempo en resolver incidencias
						</aside>
					</section>
					<section>
						<h2>¿Porqué hacen falta? (II)</h2>
						<div class="image">
							<img height="550" src="img/time_bomb.jpg">
						</div>
						<aside class="notes">
							Lo que suele suceder al proceder a desarrollar el código de esta manera es generar una bomba de relojería, que explotará en el momento en que se detecten bugs o el cliente pida cambios que no estaban previstos
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h1>SOLID</h1>
						<h3>Buenas prácticas</h3>
						<ul>
							<li class="fragment">Single Responsibility Principle</li>
							<li class="fragment">Open-Closed Principle</li>
							<li class="fragment">Liskov Substitution</li>
							<li class="fragment">Interface Segregation</li>
							<li class="fragment">Dependency Inversion</li>
						</ul>
						<aside class="notes">
							SOLID no es más que un conjunto de buenas prácticas para desarrollar software, pensadas de manera tal que, si se siguen, el software que se obtendrá será modular, evolucionable, y más reutilizable que si se siguen prácticas no recomendadas.
						</aside>
					</section>
					<section>
						<h2>Single Responsibility Principle</h2>
						<div class="image">	
							<img height="550" src="img/">
						</div>
						<aside class="notes">
							El principio de única responsabilidad lo que dicta es que cada clase debe tener *una y sólo una* responsabilidad. De esta manera, cuando se produce un error en el código es mucho más fácil ir directamente al punto en el que esta responsabilidad no está cumpliendo su cometido.

							Habitualmente, si una clase es demasiado grande significa que está haciendo más cosas de las que debe, con lo cual el código se debe refactorizar en clases más manejables que sean más fáciles de extender y mantener en el futuro.
						</aside>
					</section>
					<section>
						<h2>Open-Closed Principle</h2>
						<div class="image">
							<img height="550" src="img/">
						</div>
						<aside class="notes">
							Este principio indica que las clases deben estar abiertas a extensión pero cerradas a modificación. Esto quiere decir que lo que no se quiere es modificar el comportamiento estándar de una clase, para que sea más fácil reutilizarla. Si se cambiar el comportamiento, editándolo en lugar de ampliándolo, creamos una colisión entre lo que esperamos que haga esta clase y lo que realmente hace, dificultando en gran medida el solucionar incidencias relacionadas con esta clase o reutilizarla, puesto que ya no sabremos qué hace realmente.

							Abierta a extensión quiere decir que lo que sí se puede hacer es ampliar la funcionalidad de esta clase.
						</aside>
					</section>
					<section>
						<h2>Liskov Substitution</h2>
						<div class="image left third">
							<img height="550" src="img/car_road.jpg">
						</div>
						<div class="image left third">
							<img height="550" src="img/motorcycle_road.jpg">
						</div>
						<div class="image left third">
							<img height="550" src="img/truck_road.jpg">
						</div>
						<aside class="notes">
							El principio de sustitución de Liskov dice que una clase debe poder sustituirse por cualquiera de sus subclases y el código debe seguir funcionando.

							Lo que esto quiere decir es que si, por ejemplo, tenemos un método que espera un Vehículo, este debe poder ser sustituido indistintamente por Coche, Moto o Camión, ya que todos son Vehículos.

							Sería incorrecto si al poner un subtipo el código no hiciera lo que debe, ya que esto indica que el código está muy acoplado a un tipo concreto, lo que indica que, probablemente, deberíamos haber 
						</aside>
					</section>
					<section>
						<h2>Interface Segregation</h2>
						<div class="image">
							<img src="img/wall_sockets.jpg">
						</div>
						<aside class="notes">
							El principio de segregación por interfaces dice que lo correcto es tener un interfaz para cada cliente que vaya a consumir los servicios de una clase. De esta manera, una única clase puede reaprovechar el código internamente, dando a cada cliente el interfaz pactado que necesita. Esto se puede ver también como "diseño sobre interfaces", de manera que lo primero que se hace es ver qué interfaces se van a necesitar y, si caen sobre una única responsabilidad, asignárselos a la misma clase.

							En el ejemplo, damos el mismo servicio a todos los clientes (línea eléctrica), con lo cual estaría implementado por la misma clase para no repetir código. Sin embargo, cada cliente interacciona con esta clase de una manera distinta, de ahí que el enchufe varíe.
						</aside>
					</section>
					<section>
						<h2>Dependency Inversion</h2>
						<div class="image left third">
							<img height="500" src="img/alonso.jpg">
						</div>
						<div class="image left third">
							<img height="500" src="img/hamilton.jpg">
						</div>
						<div class="image left third">
							<img height="500" src="img/vettel.jpg">
						</div>
						<aside class="notes">
							El principio de inversión de dependencias dice que, con tal de hacer los módulos de alto nivel reutilizables, 
					</section>
				</section>




			</div>
		</div>


		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>

</html>